<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>【译】ES10功能完全指南 | Ioodu Land</title>
    <meta name="description" content="Ioodu&#39;s blog, About web front end development and everything →">
    <link rel="icon" href="/blog/favicon.ico">
    
    <link rel="preload" href="/blog/assets/css/0.styles.2567a312.css" as="style"><link rel="preload" href="/blog/assets/js/app.3d7ec90a.js" as="script"><link rel="preload" href="/blog/assets/js/7.97e05d64.js" as="script"><link rel="prefetch" href="/blog/assets/js/10.0a69e222.js"><link rel="prefetch" href="/blog/assets/js/11.28002d60.js"><link rel="prefetch" href="/blog/assets/js/2.d8f505d4.js"><link rel="prefetch" href="/blog/assets/js/3.381e31ec.js"><link rel="prefetch" href="/blog/assets/js/4.6ebbc091.js"><link rel="prefetch" href="/blog/assets/js/5.71b594bd.js"><link rel="prefetch" href="/blog/assets/js/6.619fe912.js"><link rel="prefetch" href="/blog/assets/js/8.0317f91b.js"><link rel="prefetch" href="/blog/assets/js/9.4cea35d1.js">
    <link rel="stylesheet" href="/blog/assets/css/0.styles.2567a312.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/blog/" class="home-link router-link-active"><!----> <span class="site-name">Ioodu Land</span></a> <div class="links" style="max-width:nullpx;"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/blog/" class="nav-link">Home</a></div><div class="nav-item"><a href="/blog/frontend/" class="nav-link router-link-active">Front-End</a></div> <a href="https://github.com/chinadbo" target="_blank" rel="noopener noreferrer" class="repo-link">
    查看源码
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav></div></header> <div class="sidebar-mask"></div> <div class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/blog/" class="nav-link">Home</a></div><div class="nav-item"><a href="/blog/frontend/" class="nav-link router-link-active">Front-End</a></div> <a href="https://github.com/chinadbo" target="_blank" rel="noopener noreferrer" class="repo-link">
    查看源码
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav>  <ul class="sidebar-links"><li><div class="sidebar-group first"><p class="sidebar-heading open"><span>【译】ES10功能完全指南</span> <!----></p> <ul class="sidebar-group-items"><li><a href="/blog/frontend/es10.html#bigint-任意精度整数" class="sidebar-link">BigInt - 任意精度整数</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/frontend/es10.html#typeof" class="sidebar-link">typeof</a></li><li class="sidebar-sub-header"><a href="/blog/frontend/es10.html#" class="sidebar-link">=== ==</a></li><li class="sidebar-sub-header"><a href="/blog/frontend/es10.html#-2" class="sidebar-link">* /</a></li><li class="sidebar-sub-header"><a href="/blog/frontend/es10.html#-3" class="sidebar-link">- +</a></li></ul></li><li><a href="/blog/frontend/es10.html#string-prototype-matchall" class="sidebar-link">string.prototype.matchAll()</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/frontend/es10.html#添加-g" class="sidebar-link">添加 /g</a></li><li class="sidebar-sub-header"><a href="/blog/frontend/es10.html#正则表达式捕获组" class="sidebar-link">正则表达式捕获组</a></li><li class="sidebar-sub-header"><a href="/blog/frontend/es10.html#字符串标本匹配" class="sidebar-link">字符串标本匹配</a></li><li class="sidebar-sub-header"><a href="/blog/frontend/es10.html#最好使用-matchall" class="sidebar-link">最好使用 .matchAll()</a></li><li class="sidebar-sub-header"><a href="/blog/frontend/es10.html#matchall-如何工作" class="sidebar-link">.matchAll()如何工作</a></li></ul></li><li><a href="/blog/frontend/es10.html#动态-import" class="sidebar-link">动态 import</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/blog/frontend/es10.html#array-flat" class="sidebar-link">Array.flat()</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/blog/frontend/es10.html#array-flatmap" class="sidebar-link">Array.flatMap()</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/blog/frontend/es10.html#object-fromentries" class="sidebar-link">Object.fromEntries()</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/blog/frontend/es10.html#string-trimstart-string-trimend" class="sidebar-link">String.trimStart() &amp; String.trimEnd()</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/blog/frontend/es10.html#格式良好的json-stringify" class="sidebar-link">格式良好的JSON.stringify()</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/frontend/es10.html#u-2028和u-2029字符" class="sidebar-link">U + 2028和U + 2029字符</a></li><li class="sidebar-sub-header"><a href="/blog/frontend/es10.html#对于u-d800-u-dfff之间的所有字符也是如此" class="sidebar-link">对于U + D800 - U + DFFF之间的所有字符也是如此</a></li></ul></li><li><a href="/blog/frontend/es10.html#稳定的array-prototype-sort" class="sidebar-link">稳定的Array.prototype.sort()</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/blog/frontend/es10.html#new-function-tostring" class="sidebar-link">New Function.toString()</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/frontend/es10.html#classic-example" class="sidebar-link">Classic example</a></li><li class="sidebar-sub-header"><a href="/blog/frontend/es10.html#直接来自函数名" class="sidebar-link">直接来自函数名</a></li><li class="sidebar-sub-header"><a href="/blog/frontend/es10.html#绑定上下文" class="sidebar-link">绑定上下文</a></li><li class="sidebar-sub-header"><a href="/blog/frontend/es10.html#内置可调用函数对象" class="sidebar-link">内置可调用函数对象</a></li><li class="sidebar-sub-header"><a href="/blog/frontend/es10.html#动态生成的函数" class="sidebar-link">动态生成的函数</a></li><li class="sidebar-sub-header"><a href="/blog/frontend/es10.html#动态生成的生成器-function" class="sidebar-link">动态生成的生成器 function*</a></li><li class="sidebar-sub-header"><a href="/blog/frontend/es10.html#prototype-tostring" class="sidebar-link">prototype.toString</a></li></ul></li><li><a href="/blog/frontend/es10.html#可选的catch-binding" class="sidebar-link">可选的Catch Binding</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/frontend/es10.html#在es10中，catch-error-binding是可选的" class="sidebar-link">在ES10中，Catch Error Binding是可选的</a></li></ul></li><li><a href="/blog/frontend/es10.html#标准化的-globalthis-对象" class="sidebar-link">标准化的 globalThis 对象</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/blog/frontend/es10.html#symbol-description" class="sidebar-link">Symbol.description</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/blog/frontend/es10.html#hashbang-语法" class="sidebar-link">Hashbang 语法</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/blog/frontend/es10.html#es10-classes-private-static-public-members" class="sidebar-link">ES10 Classes: private, static &amp; public members</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/blog/frontend/es10.html#总结与反馈" class="sidebar-link">总结与反馈</a><ul class="sidebar-sub-headers"></ul></li></ul></div></li></ul> </div> <div class="page"> <div class="content"><h1 id="【译】es10功能完全指南"><a href="#【译】es10功能完全指南" aria-hidden="true" class="header-anchor">#</a> 【译】ES10功能完全指南</h1> <p><code>ES10</code>仍然只是一个草案。但是除了<code>Object.fromEntries</code>大多数功能已经在<code>Chrome</code>中实现，所以你为什么不尽早开始探索它呢？当所有浏览器开始支持它时，你已经获得了领先优势，这只是时间问题。对于有兴趣探索ES10的人来说，这是一份<strong>非外星人</strong>指南。</p> <p><strong>ES10在新语言功能方面没有ES6那么重要，但它确实添加了一些有趣的东西（其中一些在目前版本的浏览器中还不起作用：02/20/2019）</strong></p> <p><img src="https://user-gold-cdn.xitu.io/2019/3/4/169469287aaf9be5?w=266&h=231&f=png&s=16878" alt></p> <p><code>ES6</code>中最受欢迎的功能莫过于<strong>箭头函数</strong>了，那么<code>ES10</code>中呢?</p> <h2 id="bigint-任意精度整数"><a href="#bigint-任意精度整数" aria-hidden="true" class="header-anchor">#</a> BigInt - 任意精度整数</h2> <p><code>BigInt</code>是第7种原始类型。</p> <p><code>BigInt</code>是一个任意精度的整数。这意味着变量现在可以代表2^53个数字。而且最大限度是9007199254740992。</p> <p><code>const b = 1n; //追加n来创建一个BigInt</code></p> <p>在过去的整数值大于9007199254740992不支持。如果超出，则该值将锁定为<code>MAX_SAFE_INTEGER + 1</code>：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">const</span> limit <span class="token operator">=</span> Number<span class="token punctuation">.</span><span class="token constant">MAX_SAFE_INTEGER</span><span class="token punctuation">;</span>
⇨ <span class="token number">9007199254740991</span>
limit <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> 
⇨ <span class="token number">9007199254740992</span>
limit <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">;</span> 
⇨ <span class="token number">9007199254740992</span> <span class="token operator">&lt;</span><span class="token operator">--</span><span class="token operator">-</span> <span class="token constant">MAX_SAFE_INTEGER</span> <span class="token operator">+</span> <span class="token number">1</span> exceeded
<span class="token keyword">const</span> larger <span class="token operator">=</span> <span class="token number">9007199254740991</span>n<span class="token punctuation">;</span>
⇨ <span class="token number">9007199254740991</span>n
<span class="token keyword">const</span> integer <span class="token operator">=</span> <span class="token function">BigInt</span><span class="token punctuation">(</span><span class="token number">9007199254740991</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// initialize with number</span>
⇨ <span class="token number">9007199254740991</span>n
<span class="token keyword">const</span> same <span class="token operator">=</span> <span class="token function">BigInt</span><span class="token punctuation">(</span><span class="token string">&quot;9007199254740991&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// initialize with &quot;string&quot;</span>
⇨ <span class="token number">9007199254740991</span>n
</code></pre></div><h3 id="typeof"><a href="#typeof" aria-hidden="true" class="header-anchor">#</a> typeof</h3> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">typeof</span> <span class="token number">10</span><span class="token punctuation">;</span>
⇨ <span class="token string">'number'</span>
<span class="token keyword">typeof</span> <span class="token number">10</span>n<span class="token punctuation">;</span>
⇨ <span class="token string">'bigint'</span>
</code></pre></div><h3 id><a href="#" aria-hidden="true" class="header-anchor">#</a> === ==</h3> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token number">10</span>n <span class="token operator">===</span> <span class="token function">BigInt</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
⇨ <span class="token boolean">true</span>
<span class="token number">10</span>n <span class="token operator">==</span> <span class="token number">10</span><span class="token punctuation">;</span>
⇨ <span class="token boolean">true</span>
</code></pre></div><h3 id="-2"><a href="#-2" aria-hidden="true" class="header-anchor">#</a> * /</h3> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token number">200</span>n <span class="token operator">/</span> <span class="token number">10</span>n
⇨ <span class="token number">20</span>n
<span class="token number">200</span>n <span class="token operator">/</span> <span class="token number">20</span>
⇨ Uncaught TypeError<span class="token punctuation">:</span>
   Cannot mix BigInt and other types<span class="token punctuation">,</span> use explicit conversions <span class="token operator">&lt;</span>
</code></pre></div><h3 id="-3"><a href="#-3" aria-hidden="true" class="header-anchor">#</a> - +</h3> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token operator">-</span><span class="token number">100</span>n
⇨ <span class="token operator">-</span><span class="token number">100</span>n
<span class="token operator">+</span><span class="token number">100</span>n
⇨ Uncaught TypeError<span class="token punctuation">:</span>
  Cannot convert a BigInt value to a number
</code></pre></div><p>当你读到这个<code>matchAll</code>时，它可能会在<code>Chrome C73</code>中正式实现 - 如果没有，它仍然值得一看。特别是如果你是一个<strong>正则表达式</strong>瘾君子。</p> <h2 id="string-prototype-matchall"><a href="#string-prototype-matchall" aria-hidden="true" class="header-anchor">#</a> string.prototype.matchAll()</h2> <p>如果你谷歌搜索&quot;javascript string match all&quot;，第一条结果可能会是这样的<strong>How do I write a regular expression to “match all”?</strong> 。 排名靠前的结果会建议你使用<code>String.match</code>匹配的时候在正则表达式或者<code>RegExp.exc</code>或者<code>RegExp.text</code>后加上<code>/g</code>...</p> <p>首先，我们来看下旧的规范是如何运行的。</p> <p><code>String.match</code>，<code>match</code>只返回字符串参数第一个符合匹配的。</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">let</span> string <span class="token operator">=</span> <span class="token string">'Hello'</span>
<span class="token keyword">let</span> matches <span class="token operator">=</span> string<span class="token punctuation">.</span><span class="token function">match</span><span class="token punctuation">(</span><span class="token string">'l'</span><span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>matches<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment">// 'l'</span>
</code></pre></div><p>匹配的结果是单个<code>'l'</code>。(注意： <code>match</code>匹配的结果存储在<code>matches[0]</code>而非在<code>matches</code>)，在字符串<code>'hello'</code>中搜索匹配<code>'l'</code>只有<code>'l'</code>被返回来。使用<code>regexp</code>参数也是得到一样的结果。</p> <p>我们把字符<code>'l'</code>更换为表达式<code>/l/</code>:</p> <div class="language- extra-class"><pre class="language-text"><code>let string = 'Hello'
let matches = string.match(/l/)
console.log(matches[0]) // 'l'
</code></pre></div><h3 id="添加-g"><a href="#添加-g" aria-hidden="true" class="header-anchor">#</a> 添加 /g</h3> <p><code>String.match</code>使用正则表达式带上<code>/g</code>标签会返回多个匹配。</p> <div class="language- extra-class"><pre class="language-text"><code>let string = 'Hello'
let ret = string.match(/l/g) // ['l', 'l']
</code></pre></div><p>Great...在低于<code>ES10</code>的环境中我们得到了多个匹配结果，并且一直有效。</p> <p>那么为什么要用全新的<code>matchAll</code>方法呢？在我们更详细地回答这个问题之前，让我们来看看<code>capture group</code>。如果不出意外，你可能会学到新的有关正则表达式的东西。</p> <h3 id="正则表达式捕获组"><a href="#正则表达式捕获组" aria-hidden="true" class="header-anchor">#</a> 正则表达式捕获组</h3> <p>在正则表达式中捕获组只是在<code>()</code>括号中提取匹配。你可以从<code>/regex/.exec(string)</code>和<code>string.match</code>捕获组。</p> <p>通常捕获组是在匹配规则中被创建的。输出对象上创建<code>groups</code>属性如： <code>(?&lt;name&gt;)</code>。要创建一个新的组名，只需在括号内添加 <code>(?&lt;name&gt;)</code>属性，分组（模式）匹配将成为附加到<code>match</code>对象的<code>groups.name</code>。</p> <p>看一个实际的例子：</p> <h3 id="字符串标本匹配"><a href="#字符串标本匹配" aria-hidden="true" class="header-anchor">#</a> 字符串标本匹配</h3> <p><img src="https://user-gold-cdn.xitu.io/2019/3/4/169473e7b91add89?w=800&h=93&f=png&s=13091" alt>
创建<code>match.groups.color &amp; match.groups.bird</code>匹配：</p> <div class="language- extra-class"><pre class="language-text"><code>const string = 'black*raven lime*parrot white*seagull'
const regex = /(?&lt;color&gt;.*?)\*(?&lt;bird&gt;[a-z0-9]+)/g
while (match = regex.exec(string) {
    let value = match[0]
    let index = match.index
    let input = match.input
    console.log(`${value} at ${index} with '${input}'`)
    console.log(match.groups.color)
    console.log(match.groups.bird)
}
</code></pre></div><p>需要多次调用<code>regex.exec</code>方法来遍历整个搜索结果。在每次迭代调用<code>.exec</code>时，会显示下一个结果（它不会立即返回所有匹配项）。</p> <p>控制台输出：</p> <div class="language- extra-class"><pre class="language-text"><code>black*raven at 0 with 'black*raven lime*parrot white*seagull'
black
raven
lime*parrot at 11 with 'black*raven lime*parrot white*seagull'
lime
parrot
white*seagull at 23 with 'black*raven lime*parrot white*seagull'
white
seagull
</code></pre></div><p>这里有一个怪事：</p> <blockquote><p>如果你从这个正则表达式中删除<code>/ g</code>，你将永远在第一个结果上创建一个无限循环循环。这在过去是一个巨大的痛苦。想象一下从某个数据库接收正则表达式，你不确定它是否在最后有<code>/ g</code>。你必须先检查它，等等。</p></blockquote> <p>现在我们有足够的背景知识回答这个问题：</p> <h3 id="最好使用-matchall"><a href="#最好使用-matchall" aria-hidden="true" class="header-anchor">#</a> 最好使用 <code>.matchAll()</code></h3> <ol><li>使用捕获组时更加优雅。捕获组知识带有提取模式（）的正则表达式的一部分。</li> <li>它返回一个<strong>迭代器</strong>而不是数组，迭代器本身很有用。</li> <li>可以使用<strong>扩展运算符...<strong>将</strong>迭代器</strong>转为<strong>数组</strong>。</li> <li>它<strong>避免</strong>使用带<code>/g</code>标志的<strong>正则表达式</strong>...当从数据库或外部源检索未知的正则表达式并与古老的RegEx对象一起使用时非常有用。</li> <li>使用<code>RegExp</code>对象创建的正则表达式不能使用点（<code>.</code>）运算符链接。</li> <li>**高级：<code>RegEx</code>**对象跟踪最后匹配位置的内部<code>.lastIndex</code>属性，这可能对复杂案例有破坏性的事情。</li></ol> <h3 id="matchall-如何工作"><a href="#matchall-如何工作" aria-hidden="true" class="header-anchor">#</a> <code>.matchAll()</code>如何工作</h3> <p>这是一简单个例子。</p> <p>我们尝试匹配字符串<code>Hello</code>的所有<code>e</code>和<code>l</code>。因为返回了<strong>iterator</strong>,所以我们用<code>for ... of</code>处理它。</p> <div class="language- extra-class"><pre class="language-text"><code>// Match all occurrences of the letters: 'e' 或者 'l'
let iterator = 'hello'.matchAll(/[el]/)
for (const match of iterator) {
    console.log(match)
}
</code></pre></div><p>如上，你可以跳过<code>/g</code>，<code>.matchAll</code>不需要它。结果：</p> <div class="language- extra-class"><pre class="language-text"><code>[ 'e', index: 1, input: 'hello' ] // Iteration 1
[ 'l', index: 2, input: 'hello' ] // Iteration 2
[ 'l', index: 3, input: 'hello' ] // Iteration 3
</code></pre></div><p>使用<code>.matchAll()</code>捕获组示例：
<code>.matchAll()</code>具有上面列举的所有好处，它是一个<strong>迭代器</strong>，所以我们可以用它来循环，这就是整个<strong>句法</strong>差异。</p> <div class="language- extra-class"><pre class="language-text"><code>const string = 'black*raven lime*parrot white*seagull';
const regex = /(?&lt;color&gt;.*?)\*(?&lt;bird&gt;[a-z0-9]+)/;
for (const match of string.matchAll(regex)) {
    let value = match[0];
    let index = match.index;
    let input = match.input;
    console.log(`${value} at ${index} with '${input}'`);
    console.log(match.groups.color);
    console.log(match.groups.bird);
}
</code></pre></div><p>注意去掉<code>/g</code>标志，因为<code>.matchAll()</code>已经隐含了它。</p> <p>结果输出：</p> <div class="language- extra-class"><pre class="language-text"><code>black*raven at 0 with 'black*raven lime*parrot white*seagull'
black
raven
lime*parrot at 11 with 'black*raven lime*parrot white*seagull'
lime
parrot
white*seagull at 23 with 'black*raven lime*parrot white*seagull'
white
seagull
</code></pre></div><p>也许在美学上它与循环实现时的原始<code>regex.exec</code>非常相似。但如前所述，由于上述许多原因，这是更好的方法。并且删除<code>/ g</code>不会导致无限循环。</p> <h2 id="动态-import"><a href="#动态-import" aria-hidden="true" class="header-anchor">#</a> 动态 import</h2> <p>现在可以将导入分配给一个变量：</p> <div class="language- extra-class"><pre class="language-text"><code>element.addEventListener('click', async () =&gt; {
    const module = await import('./api-scripts/button-click.js')
    module.clickEvent()
})
</code></pre></div><h2 id="array-flat"><a href="#array-flat" aria-hidden="true" class="header-anchor">#</a> Array.flat()</h2> <p>扁平化多维数组：</p> <div class="language- extra-class"><pre class="language-text"><code>let multi = [1,2,3,[4,5,6,[7,8,9,[10,11,12]]]];
multi.flat();               // [1,2,3,4,5,6,Array(4)]
multi.flat().flat();        // [1,2,3,4,5,6,7,8,9,Array(3)]
multi.flat().flat().flat(); // [1,2,3,4,5,6,7,8,9,10,11,12]
multi.flat(Infinity);       // [1,2,3,4,5,6,7,8,9,10,11,12]
</code></pre></div><h2 id="array-flatmap"><a href="#array-flatmap" aria-hidden="true" class="header-anchor">#</a> Array.flatMap()</h2> <div class="language- extra-class"><pre class="language-text"><code>let array = [1, 2, 3, 4, 5]
array.map(x =&gt; [x, x * 2])
</code></pre></div><p>变为：</p> <div class="language- extra-class"><pre class="language-text"><code>[Array(2), Array(2), Array(2)]
0: (2)[1, 2]
1: (2)[2, 4]
2: (2)[3, 6]
3: (2)[4, 8]
4: (2)[5, 10]
</code></pre></div><p>再次扁平化数组：</p> <div class="language- extra-class"><pre class="language-text"><code>array.flatMap(v =&gt; [v, v * 2])
[1, 2, 2, 4, 3, 6, 4, 8, 5, 10]
</code></pre></div><h2 id="object-fromentries"><a href="#object-fromentries" aria-hidden="true" class="header-anchor">#</a> Object.fromEntries()</h2> <p>将键值对列表转换为对象。</p> <div class="language- extra-class"><pre class="language-text"><code>let obj = { apple : 10, orange : 20, banana : 30 };
let entries = Object.entries(obj);
entries;
(3) [Array(2), Array(2), Array(2)]
 0: (2) [&quot;apple&quot;, 10]
 1: (2) [&quot;orange&quot;, 20]
 2: (2) [&quot;banana&quot;, 30]
let fromEntries = Object.fromEntries(entries);
{ apple: 10, orange: 20, banana: 30 }
</code></pre></div><h2 id="string-trimstart-string-trimend"><a href="#string-trimstart-string-trimend" aria-hidden="true" class="header-anchor">#</a> String.trimStart() &amp; String.trimEnd()</h2> <div class="language- extra-class"><pre class="language-text"><code>let greeting = &quot;     Space around     &quot;;
greeting.trimEnd();   // &quot;     Space around&quot;;
greeting.trimStart(); // &quot;Space around     &quot;;
</code></pre></div><h2 id="格式良好的json-stringify"><a href="#格式良好的json-stringify" aria-hidden="true" class="header-anchor">#</a> 格式良好的JSON.stringify()</h2> <p>此更新修复了字符<code>U + D800</code>到<code>U + DFFF</code>的处理，有时可以进入<code>JSON</code>字符串。这可能是一个问题，因为<code>JSON.stringify</code>可能会返回格式化为没有等效<code>UTF-8</code>字符的值的这些数字。但<code>JSON</code>格式需要<code>UTF-8</code>编码。</p> <p><code>JSON</code> 对象可用于解析<code>JSON</code> 格式（但也更多。）<code>JavaScript JSON</code> 对象也具有<code>stringify</code>和<code>parse</code>方法。</p> <p>该解析方法适用于一个结构良好的<code>JSON</code>字符串，如：</p> <p><code>'{ “prop1” : 1, &quot;prop2&quot; : 2 }'; // A well-formed JSON format string</code></p> <p>请注意，创建具有正确<code>JSON</code>格式的字符串绝对需要使用围绕属性名称的双引号。缺少<code>...</code>或任何其他类型的引号将不会产生格式良好的<code>JSON</code>。</p> <p><code>'{ “prop1” : 1, &quot;meth&quot; : () =&gt; {}}'; // Not JSON format string</code></p> <p><code>JSON</code> 字符串格式是不同的，从对象文本 ......它看起来几乎相同，但可以使用任何类型的周围属性名称的报价，还可以包括方法（JSON格式不允许的方法）：</p> <p><code>let object_literal = { property：1，meth：（）=&gt; {} };</code></p> <p>无论如何，一切似乎都很好。第一个示例看起来合规。但它们也是简单的例子，大部分时间都可以毫无障碍地工作！</p> <h3 id="u-2028和u-2029字符"><a href="#u-2028和u-2029字符" aria-hidden="true" class="header-anchor">#</a> U + 2028和U + 2029字符</h3> <p>这是捕获。<code>ES10</code>之前的<code>EcmaScript</code>实际上并不完全支持<code>JSON</code>格式。在<code>ES10</code>之前的时代，不接受未转义的行分隔符<code>U + 2028</code>和段落分隔符<code>U + 2029</code>字符：</p> <p><img src="https://user-gold-cdn.xitu.io/2019/3/4/169477e8ddcb5f5b?w=525&h=97&f=png&s=2890" alt>
U + 2029是行分隔符。</p> <p><img src="https://user-gold-cdn.xitu.io/2019/3/4/169477eaec7e96e6?w=525&h=97&f=png&s=3137" alt>
U + 2029是段落分隔符。有时它可能会潜入您的JSON格式字符串。</p> <h3 id="对于u-d800-u-dfff之间的所有字符也是如此"><a href="#对于u-d800-u-dfff之间的所有字符也是如此" aria-hidden="true" class="header-anchor">#</a> 对于U + D800 - U + DFFF之间的所有字符也是如此</h3> <p>如果这些字符悄悄进入你的JSON格式的字符串（比如说来自数据库记录），你最终可能花费数小时试图弄清楚为什么程序的其余部分会产生解析错误。</p> <p>所以，如果你传递的<code>eval</code>一个字符串，像“<code>console.log(‘hello’)</code>”这将执行<code>JavaScript</code>语句（试图通过字符串实际代码转换。）这也类似于如何<code>JSON.parse</code>将处理您的<code>JSON</code>字符串。</p> <h2 id="稳定的array-prototype-sort"><a href="#稳定的array-prototype-sort" aria-hidden="true" class="header-anchor">#</a> 稳定的Array.prototype.sort()</h2> <p><strong>V8</strong>的先前实现对包含10个以上项的数组使用了<strong>不稳定</strong>的快速排序算法。</p> <blockquote><p>一个稳定的排序算法是当两个具有相等键的对象在排序输出中以与未排序输入中出现的顺序相同的顺序出现时。</p></blockquote> <p>但现在已经不是这样了。ES10提供稳定的阵列排序：</p> <div class="language- extra-class"><pre class="language-text"><code>var fruit = [
    { name: &quot;Apple&quot;,      count: 13, },
    { name: &quot;Pear&quot;,       count: 12, },
    { name: &quot;Banana&quot;,     count: 12, },
    { name: &quot;Strawberry&quot;, count: 11, },
    { name: &quot;Cherry&quot;,     count: 11, },
    { name: &quot;Blackberry&quot;, count: 10, },
    { name: &quot;Pineapple&quot;,  count: 10, }
];
// Create our own sort criteria function:
let my_sort = (a, b) =&gt; a.count - b.count;
// Perform stable ES10 sort:
let sorted = fruit.sort(my_sort);
console.log(sorted);
</code></pre></div><p>控制台输出（项目以相反的顺序出现）：</p> <p><img src="https://user-gold-cdn.xitu.io/2019/3/4/16947822971b1b2d?w=800&h=322&f=png&s=78946" alt></p> <h2 id="new-function-tostring"><a href="#new-function-tostring" aria-hidden="true" class="header-anchor">#</a> New Function.toString()</h2> <p>Funcitons是对象，每个对象都有个<code>.toString()</code>方法因为它最初存在于<code>Object.prototype.toString()</code>。所有的<code>objects</code>（包括functions）都继承至基于原型的类继承。这意味着我们已经有了<code>function.toString()</code>方法了。</p> <p>但是ES10进一步尝试标准化所有对象和内置函数的字符串表示。以下新案例：</p> <h3 id="classic-example"><a href="#classic-example" aria-hidden="true" class="header-anchor">#</a> Classic example</h3> <div class="language- extra-class"><pre class="language-text"><code>function () { console.log('Hello there.'); }.toString();
</code></pre></div><p>控制台输出（字符串格式的函数体:)</p> <div class="language- extra-class"><pre class="language-text"><code>⇨ function () { console.log('Hello there.'); }
</code></pre></div><p>以下是其它案例：</p> <h3 id="直接来自函数名"><a href="#直接来自函数名" aria-hidden="true" class="header-anchor">#</a> 直接来自函数名</h3> <div class="language- extra-class"><pre class="language-text"><code>Number.parseInt.toString();
⇨ function parseInt() { [native code] }
</code></pre></div><h3 id="绑定上下文"><a href="#绑定上下文" aria-hidden="true" class="header-anchor">#</a> 绑定上下文</h3> <div class="language- extra-class"><pre class="language-text"><code>function () { }.bind(0).toString();
⇨ function () { [native code] }
</code></pre></div><h3 id="内置可调用函数对象"><a href="#内置可调用函数对象" aria-hidden="true" class="header-anchor">#</a> 内置可调用函数对象</h3> <div class="language- extra-class"><pre class="language-text"><code>Symbol.toString();
⇨ function Symbol() { [native code] }
</code></pre></div><h3 id="动态生成的函数"><a href="#动态生成的函数" aria-hidden="true" class="header-anchor">#</a> 动态生成的函数</h3> <div class="language- extra-class"><pre class="language-text"><code>Function().toString();
⇨ function anonymous() {}
</code></pre></div><h3 id="动态生成的生成器-function"><a href="#动态生成的生成器-function" aria-hidden="true" class="header-anchor">#</a> 动态生成的生成器 function*</h3> <div class="language- extra-class"><pre class="language-text"><code>function* () { }.toString();
⇨ function* () { }
</code></pre></div><h3 id="prototype-tostring"><a href="#prototype-tostring" aria-hidden="true" class="header-anchor">#</a> prototype.toString</h3> <div class="language- extra-class"><pre class="language-text"><code>Function.prototype.toString.call({});
⇨ Function.prototype.toString requires that 'this' be a Function&quot;
</code></pre></div><h2 id="可选的catch-binding"><a href="#可选的catch-binding" aria-hidden="true" class="header-anchor">#</a> 可选的Catch Binding</h2> <p>在过去，<code>try / catch</code>语句中的<code>catch</code>子句需要一个变量。</p> <p><code>try / catch</code>语句帮助我们拦截在终端层面的错误：</p> <p>这是一个复习:</p> <div class="language- extra-class"><pre class="language-text"><code>try {
    // Call a non-existing function undefined_Function
    undefined_Function(&quot;I'm trying&quot;);
}
catch(error) {
    // Display the error if statements inside try above fail
    console.log( error ); // undefined_Function is undefined
}
</code></pre></div><p>但在某些情况下，所需的<code>error</code>变量未被使用：</p> <div class="language- extra-class"><pre class="language-text"><code>try {
    JSON.parse(text); // &lt;--- this will fail with &quot;text not defined&quot;
    return true; &lt;--- exit without error even if there is one
}
catch (redundant_sometmes) &lt;--- this makes error variable redundant
{
    return false;
}
</code></pre></div><p>编写此代码的人尝试通过强制为<code>true</code>退出<code>try</code>子句。但是......事实并非如此(正如<a href="https://medium.com/@douglas.massolari" target="_blank" rel="noopener noreferrer"> Douglas Massolari.<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>所说)。</p> <div class="language- extra-class"><pre class="language-text"><code>(() =&gt; {
    try {
        JSON.parse(text)
        return true
    } catch(err) {
        return false
    }
})()
=&gt; false
</code></pre></div><h3 id="在es10中，catch-error-binding是可选的"><a href="#在es10中，catch-error-binding是可选的" aria-hidden="true" class="header-anchor">#</a> 在ES10中，Catch Error Binding是可选的</h3> <p>你现在可以跳过<code>error</code>变量：</p> <div class="language- extra-class"><pre class="language-text"><code>try {
    JSON.parse(text);
    return true;
}
catch
{
    return false;
}
</code></pre></div><h2 id="标准化的-globalthis-对象"><a href="#标准化的-globalthis-对象" aria-hidden="true" class="header-anchor">#</a> 标准化的 globalThis 对象</h2> <p>ES10之前全局<code>this</code>没有标准化。</p> <p>生产代码中，你必须手动添加如下代码来标准化多个平台的全局对象。</p> <div class="language- extra-class"><pre class="language-text"><code>var getGlobal = function () {
    if (typeof self !== 'undefined') { return self; }
    if (typeof window !== 'undefined') { return window; }
    if (typeof global !== 'undefined') { return global; }
    throw new Error('unable to locate global object');
};
</code></pre></div><p>但即使这样也并不总是奏效。所以<code>ES10</code>添加了<code>globalThis</code>对象，从现在开始应该在任何平台上访问全局作用域：</p> <div class="language- extra-class"><pre class="language-text"><code>// Access global array constructor
globalThis.Array(0, 1, 2);
⇨ [0, 1, 2]

// Similar to window.v = { flag: true } in &lt;= ES5
globalThis.v = { flag: true };

console.log(globalThis.v);
⇨ { flag: true }
</code></pre></div><h2 id="symbol-description"><a href="#symbol-description" aria-hidden="true" class="header-anchor">#</a> Symbol.description</h2> <p><code>description</code> 是一个只读属性，返回<code>Symbol</code> 对象的可选描述。</p> <div class="language- extra-class"><pre class="language-text"><code>let mySymbol = 'My Symbol';
let symObj = Symbol(mySymbol);
symObj; // Symbol(My Symbol)
String(symObj) === `Symbol(${mySymbol})`); // true
symObj.description; // &quot;My Symbol&quot;
</code></pre></div><h2 id="hashbang-语法"><a href="#hashbang-语法" aria-hidden="true" class="header-anchor">#</a> Hashbang 语法</h2> <p><code>shebang unix</code>用户会熟悉<code>AKA</code>。</p> <p>它指定一个解释器（什么将执行您的JavaScript文件？）</p> <p>ES10标准化了这一点。我不会详细介绍这个，因为这在技术上并不是一个真正的语言功能。但它基本上统一了JavaScript在服务器端的执行方式。</p> <div class="language- extra-class"><pre class="language-text"><code>$ ./index.js
</code></pre></div><p>代替：</p> <div class="language- extra-class"><pre class="language-text"><code>$ node index.js
</code></pre></div><blockquote><p>在类Unix操作系统下。</p></blockquote> <h2 id="es10-classes-private-static-public-members"><a href="#es10-classes-private-static-public-members" aria-hidden="true" class="header-anchor">#</a> ES10 Classes: private, static &amp; public members</h2> <p><strong>新的语法字符#（hash tag）现在直接在类主体作用域以及<code>constructor</code>和类方法里被用来定义<code>variables</code>， <code>functions</code>，<code>getters</code>和<code>setters</code></strong></p> <p>这是一个相当无意义的示例，仅关注新语法：</p> <div class="language- extra-class"><pre class="language-text"><code>class Raven extends Bird {
    #state = { eggs: 10};
    // getter
    get #eggs() { 
        return state.eggs;
    }
    // setter
    set #eggs(value) {
        this.#state.eggs = value;
    }
    #lay() {
        this.#eggs++;
    }
    constructor() {
        super();
        this.#lay.bind(this);
    }
    #render() {
        /* paint UI */
    }
}
</code></pre></div><p>说实话，我认为它使语言更难阅读。</p> <p>它仍然是我最喜欢的新功能，因为我喜欢<code>C ++</code>时代的<code>classes</code>。</p> <p><img src="https://user-gold-cdn.xitu.io/2019/3/4/16947beaf758e395?w=732&h=647&f=png&s=49119" alt></p> <p><img src="https://user-gold-cdn.xitu.io/2019/3/4/16947bf0ad30626a?w=800&h=450&f=png&s=490379" alt></p> <h2 id="总结与反馈"><a href="#总结与反馈" aria-hidden="true" class="header-anchor">#</a> 总结与反馈</h2> <p>ES10是一套尚未有机会在生产环境中进行全面探索的新功能。如果您有任何更正，建议或任何其他反馈，请告诉我们。</p> <p>我经常写一个教程，因为我想自己学习一些科目。这是其中一次,有其他人已经编译的资源的帮助：</p> <p>感谢Sergey Podgornyy写了这篇<a href="https://blog.larapulse.com/es-2015/ecmascript-10" target="_blank" rel="noopener noreferrer">ES10教程<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>。
感谢 Selvaganesh写了这篇<a href="https://medium.com/@selvaganesh93/javascript-whats-new-in-ecmascript-2019-es2019-es10-35210c6e7f4b" target="_blank" rel="noopener noreferrer">ES10教程<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>。</p></div> <div class="page-edit"><div class="edit-link"><a href="https://github.com/chinadbo/blog/edit/master/docs/frontend/es10.md" target="_blank" rel="noopener noreferrer">帮助改善页面！</a> <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></div> <div class="last-updated"><span class="prefix">Last Updated: </span> <span class="time">3/14/2019, 5:46:53 PM</span></div></div> <!----> </div> <!----></div></div>
    <script src="/blog/assets/js/app.3d7ec90a.js" defer></script><script src="/blog/assets/js/7.97e05d64.js" defer></script>
  </body>
</html>
