<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>揭秘JavaScript中“神秘”的this关键字 | Ioodu Land</title>
    <meta name="description" content="Ioodu&#39;s blog, About web front end development and everything →">
    <link rel="icon" href="/blog/favicon.ico">
    
    <link rel="preload" href="/blog/assets/css/0.styles.2567a312.css" as="style"><link rel="preload" href="/blog/assets/js/app.7b3236d9.js" as="script"><link rel="preload" href="/blog/assets/js/9.4cea35d1.js" as="script"><link rel="prefetch" href="/blog/assets/js/10.0a69e222.js"><link rel="prefetch" href="/blog/assets/js/11.28002d60.js"><link rel="prefetch" href="/blog/assets/js/2.d8f505d4.js"><link rel="prefetch" href="/blog/assets/js/3.b8212a47.js"><link rel="prefetch" href="/blog/assets/js/4.07c807e4.js"><link rel="prefetch" href="/blog/assets/js/5.71b594bd.js"><link rel="prefetch" href="/blog/assets/js/6.619fe912.js"><link rel="prefetch" href="/blog/assets/js/7.97e05d64.js"><link rel="prefetch" href="/blog/assets/js/8.a1d53110.js">
    <link rel="stylesheet" href="/blog/assets/css/0.styles.2567a312.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/blog/" class="home-link router-link-active"><!----> <span class="site-name">Ioodu Land</span></a> <div class="links" style="max-width:nullpx;"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/blog/" class="nav-link">Home</a></div><div class="nav-item"><a href="/blog/frontend/" class="nav-link router-link-active">Front-End</a></div> <a href="https://github.com/chinadbo" target="_blank" rel="noopener noreferrer" class="repo-link">
    查看源码
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav></div></header> <div class="sidebar-mask"></div> <div class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/blog/" class="nav-link">Home</a></div><div class="nav-item"><a href="/blog/frontend/" class="nav-link router-link-active">Front-End</a></div> <a href="https://github.com/chinadbo" target="_blank" rel="noopener noreferrer" class="repo-link">
    查看源码
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav>  <ul class="sidebar-links"><li><div class="sidebar-group first"><p class="sidebar-heading open"><span>揭秘JavaScript中“神秘”的this关键字</span> <!----></p> <ul class="sidebar-group-items"><li><a href="/blog/frontend/jsthis.html#箭头函数" class="sidebar-link">箭头函数</a><ul class="sidebar-sub-headers"></ul></li></ul></div></li></ul> </div> <div class="page"> <div class="content"><h1 id="揭秘javascript中“神秘”的this关键字"><a href="#揭秘javascript中“神秘”的this关键字" aria-hidden="true" class="header-anchor">#</a> 揭秘JavaScript中“神秘”的this关键字</h1> <p><img src="https://user-gold-cdn.xitu.io/2019/3/5/1694ba9cc370a928?w=800&h=533&f=png&s=584832" alt></p> <p>当我开始学习<code>JavaScript</code>时，花了一些时间来理解<code>JavaScript</code>中的<code>this</code>关键字并且能够快速识别<code>this</code>关键字所指向的对象。我发现理解<code>this</code>关键字最困难的事情是，您通常会忘记在您已阅读或观看过一些<code>JavaScript</code>课程或资源中解释的不同案例情况。在<code>ES6</code>中引入箭头函数后，事情变得更加混乱，因为箭头函数<code>this</code>以不同的方式处理关键字。我想写这篇文章来陈述我学到的东西，并尝试以一种可以帮助任何正在学习<code>JavaScript</code>并且难以理解<code>this</code>关键字的人的方式来解释它。</p> <p>您可能知道，执行任何<code>JavaScript</code>行的环境（或<code>scope</code>）称为“<strong>执行上下文</strong>”。<strong><code>Javascript</code>运行时</strong>维护这些执行上下文的堆栈，并且当前正在执行存在于该堆栈顶部的执行上下文。<code>this</code>变量引用的对象每次更改执行上下文时都会更改。</p> <p>默认情况下，执行上下文是全局的，这意味着如果代码作为简单函数调用的一部分执行，则该<code>this</code>变量将引用<strong>全局对象</strong>。在浏览器的情况下，全局对象是<code>window</code>对象。例如，在<code>Node.js</code>环境中，this值是一个特殊对象<code>global</code>。</p> <p>例如，尝试以下简单的函数调用：</p> <div class="language- extra-class"><pre class="language-text"><code>function foo () {
  console.log(&quot;Simple function call&quot;);
  console.log(this === window);
}
foo();
</code></pre></div><p>调用<code>foo()</code>，得到输出：</p> <div class="language- extra-class"><pre class="language-text"><code>“Simple function call”
true
</code></pre></div><p>证明这里的<code>this</code>指向全局对象，此例中为<code>window</code>。</p> <p>注意，如果实在<strong>严格模式</strong>下，<code>this</code>的值将是<code>undefined</code>，因为在严格模式下全局对象指向<code>undefined</code>而不是<code>window</code>。</p> <p>试一下如下示例：</p> <div class="language- extra-class"><pre class="language-text"><code>function foo () {
  'use strict';
  console.log(&quot;Simple function call&quot;);
  console.log(this === window);
}
foo();
</code></pre></div><p>输出：</p> <div class="language- extra-class"><pre class="language-text"><code>“Simple function call”
false
</code></pre></div><p>我们再来试下有<strong>构造函数</strong>的：</p> <div class="language- extra-class"><pre class="language-text"><code>function Person(first_name, last_name) {
    this.first_name = first_name;
    this.last_name = last_name;
  
    this.displayName = function() {
        console.log(`Name: ${this.first_name} ${this.last_name}`);
    };
}
</code></pre></div><p>创建<code>Person</code>实例：</p> <div class="language- extra-class"><pre class="language-text"><code>let john = new Person('John', 'Reid');
john.displayName();
</code></pre></div><p>得到结果：</p> <div class="language- extra-class"><pre class="language-text"><code>&quot;Name: John Reid&quot;
</code></pre></div><p>这里发生了什么？当我们调用 <code>new Person</code>，<code>JavaScript</code>会在<code>Person</code>函数内创建一个新对象并把它保存为<code>this</code>。接着，<code>first_name</code>, <code>last_name</code> 和 <code>displayName</code> 属性会被添加到新创建的<code>this</code>对象上。如下：</p> <p><img src="https://user-gold-cdn.xitu.io/2019/3/5/1694bc389b7febfb?w=800&h=642&f=png&s=116051" alt></p> <p>你会注意到在<code>Person</code>的<strong>执行上下文</strong>中创建了<code>this</code>对象，这个对象有<code>first_name</code>, <code>last_name</code> 和 <code>displayName</code> 属性。希望您能根据上图理解<code>this</code>对象是如何创建并添加属性的。</p> <p>我们已经探讨了两种相关<code>this</code>绑定的普通案例我不得不提出下面这个更加困惑的例子，如下函数：</p> <div class="language- extra-class"><pre class="language-text"><code>function simpleFunction () {
    console.log(&quot;Simple function call&quot;)
    console.log(this === window); 
}
</code></pre></div><p>我们已经知道如果像下面这样作为简单函数调用，<code>this</code>关键字将指向全局对象，此例中为<code>window</code>对象。</p> <div class="language- extra-class"><pre class="language-text"><code>simpleFunction()
</code></pre></div><p>因此，得到输出：</p> <div class="language- extra-class"><pre class="language-text"><code>“Simple function call”
true
</code></pre></div><p>创建一个简单的<code>user</code>对象：</p> <div class="language- extra-class"><pre class="language-text"><code>let user = {
    count: 10,
    simpleFunction: simpleFunction,
    anotherFunction: function() {
        console.log(this === window);
    }
}
</code></pre></div><p>现在，我们有一个<code>simpleFunction</code>属性指向<code>simpleFunction</code>函数，同样添加另一个属性调用<code>anotherFunction</code>函数方法。</p> <p>如果调用<code>user.simpleFunction()</code>，得到输出：</p> <div class="language- extra-class"><pre class="language-text"><code>“Simple function call”
false
</code></pre></div><p>为什么会这样呢？因为<code>simpleFunction()</code>现在是<code>user</code>对象的一个属性，所以<code>this</code>指向这个<code>user</code>对象而不是全局对象。</p> <p>当我们调用<code>user.anotherFunction</code>，也是一样的结果。<code>this</code>关键字指向<code>user</code>对象。所以，<code>console.log(this === window);</code>应该返回<code>false</code>:</p> <div class="language- extra-class"><pre class="language-text"><code>false
</code></pre></div><p>再来，以下操作会返回什么呢？</p> <div class="language- extra-class"><pre class="language-text"><code>let myFunction = user.anotherFunction;
myFunction();
</code></pre></div><p>现在，得到结果：</p> <div class="language- extra-class"><pre class="language-text"><code>true
</code></pre></div><p>所以这又发生了什么？在这个例子中，我们发起普通函数调用。正如之前所知，如果一个方法以普通函数方式执行，那么<code>this</code>关键字将指向全局对象（在这个例子中是<code>window</code>对象）。所以<code>console.log(this === window);</code>输出<code>true</code>。</p> <p>再看一个例子：</p> <div class="language- extra-class"><pre class="language-text"><code>var john = {
    name: 'john',
    yearOfBirth: 1990,
    calculateAge: function() {
        console.log(this);
        console.log(2016 - this.yearOfBirth);
        function innerFunction() {
            console.log(this);
        }
        innerFunction();
    }
}
</code></pre></div><p>调用<code>john.calculateAge()</code>会发生什么呢？</p> <div class="language- extra-class"><pre class="language-text"><code>{name: &quot;john&quot;, yearOfBirth: 1990, calculateAge: ƒ}
26
Window {postMessage: ƒ, blur: ƒ, focus: ƒ, close: ƒ, parent: Window, …}
</code></pre></div><p><code>calculateAge</code>函数内部， <code>this</code> 指向 <code>john</code>对象，但是，在<code>innerFunction</code>函数内部，<code>this</code>指向全局对象（本例中为<code>window</code>），有些人认为这是<code>JS</code>的bug，但是规则告诉我们无论何时一个普通函数被调用时，那么<code>this</code>将指向全局对象。</p> <p>...</p> <p>我所学的<code>JavaScript</code>函数也是一种特殊的对象，每个函数都有<code>call</code>, <code>apply</code>, <code>bind</code>方法。这些方法被用来设置函数的执行上下文的<code>this</code>值。</p> <div class="language- extra-class"><pre class="language-text"><code>function Person(firstName, lastName) {
    this.firstName = firstName;
    this.lastName = lastName;
    this.displayName = function() {
        console.log(`Name: ${this.firstName} ${this.lastName}`);
    }
}
</code></pre></div><p>创建两个实例：</p> <div class="language- extra-class"><pre class="language-text"><code>let person = new Person(&quot;John&quot;, &quot;Reed&quot;);
let person2 = new Person(&quot;Paul&quot;, &quot;Adams&quot;);
</code></pre></div><p>调用：</p> <div class="language- extra-class"><pre class="language-text"><code>person.displayName();
person2.displayName();
</code></pre></div><p>结果：</p> <div class="language- extra-class"><pre class="language-text"><code>Name: John Reed
Name: Paul Adams
</code></pre></div><p>call：</p> <div class="language- extra-class"><pre class="language-text"><code>person.displayName.call(person2);
</code></pre></div><p>上面所做的事情就是设置<code>this</code>的值为<code>person2</code>对象。因此，</p> <div class="language- extra-class"><pre class="language-text"><code>Name: Paul Adams
</code></pre></div><p>apply：</p> <div class="language- extra-class"><pre class="language-text"><code>person.displayName.apply([person2]);
</code></pre></div><p>得到：</p> <div class="language- extra-class"><pre class="language-text"><code>Name: Paul Adams
</code></pre></div><p><code>call</code>，<code>apply</code>唯一的区别就是参数的传递形式，<code>apply</code>应该传递一个数组，<code>call</code>则应该单独传递参数。</p> <p>我们用<code>bind</code>来做同样的事情，<code>bind</code>返回一个新的方法，这个方法中的<code>this</code>指向传递的第一个参数。</p> <div class="language- extra-class"><pre class="language-text"><code>let person2Display = person.displayName.bind(person2);
</code></pre></div><p>调用<code>person2Display</code>，得到<code>Name: Paul Adams</code>结果。</p> <p>...</p> <h2 id="箭头函数"><a href="#箭头函数" aria-hidden="true" class="header-anchor">#</a> 箭头函数</h2> <p>ES6中，有一个新方法定义函数。如下：</p> <div class="language- extra-class"><pre class="language-text"><code>let displayName = (firstName, lastName) =&gt; {
    console.log(Name: ${firstName} ${lastName});
};
</code></pre></div><p>不像通常的函数，箭头函数没有他们自身的<code>this</code>关键字。他们只是简单的使用写在函数里的<code>this</code>关键字。他们有一个<code>this</code>词法变量。</p> <p>ES5：</p> <div class="language- extra-class"><pre class="language-text"><code>var box = {
    color: 'green', // 1
    position: 1, // 2
    clickMe: function() { // 3
        document.querySelector('body').addEventListener('click', function() {
            var str = 'This is box number ' + this.position + ' and it is ' + this.color; // 4
            alert(str);
        });
    }
}
</code></pre></div><p>如果调用：</p> <div class="language- extra-class"><pre class="language-text"><code>box.clickMe()
</code></pre></div><p>弹出框内容将是<code>This is box number undefined and it is undefined'</code>.</p> <p>我们一步一步来分析是怎么回事。在<code>//1</code>和<code>//2</code>行，<code>this</code>关键字能访问到<code>color</code>和<code>position</code>属性因为它指向<code>box</code>对象。在<code>clickMe</code>方法内部，<code>this</code>关键字能访问到<code>color</code>和<code>position</code>属性因为它也指向<code>box</code>对象。但是，<code>clickMe</code>方法为<code>querySelector</code>方法定义了一个回调函数，然后这个回调函数以普通函数的形式调用，所以<code>this</code>指向全局对象而非<code>box</code>对象。当然，全局对象没有定义<code>color</code>和<code>position</code>属性，所以这就是为什么我们得到了<code>undefined</code>值。</p> <p>我们可以用ES5的方法来修复这个问题：</p> <div class="language- extra-class"><pre class="language-text"><code>var box = {
    color: 'green',
    position: 1,
    clickMe: function() {
        var self = this;
        document.querySelector('body').addEventListener('click', function() {
            var str = 'This is box number ' + self.position + ' and it is ' + self.color;
            alert(str);
        });
    }
}
</code></pre></div><p>添加 <code>var self = this</code>，创建了一个可以使用指向<code>box</code>对象的<code>this</code>关键字的闭包函数的工作区。我们仅仅只需要在回调函数内使用<code>self</code>变量。</p> <p>调用：</p> <div class="language- extra-class"><pre class="language-text"><code>box.clickMe();
</code></pre></div><p>弹出框内容<code>This is box number 1 and it is green</code>。</p> <p>怎么使用箭头函数能够达到上述效果呢？我们将用箭头函数替换点击函数的回调函数。</p> <div class="language- extra-class"><pre class="language-text"><code>var box = {
    color: 'green',
    position: 1,
    clickMe: function() {
        document.querySelector('body').addEventListener('click', () =&gt; {
            var str = 'This is box number ' + this.position + ' and it is ' + this.color;
            alert(str);
        });
    }
}
</code></pre></div><p>箭头函数的神奇之处就是共享包裹它的<code>this</code>词法关键字。所以，本例中外层函数的<code>this</code>共享给箭头函数，这个外层函数的<code>this</code>关键字指向<code>box</code>对象，因此，<code>color</code>和<code>position</code>属性将是有正确的<code>green</code>和<code>1</code>值。</p> <p>再来一个：</p> <div class="language- extra-class"><pre class="language-text"><code>var box = {
    color: 'green',
    position: 1,
    clickMe: () =&gt; {
        document.querySelector('body').addEventListener('click', () =&gt; {
            var str = 'This is box number ' + this.position + ' and it is ' + this.color;
            alert(str);
        });
    }
}
</code></pre></div><p>oh！现在又弹出了<code>‘This is box number undefined and it is undefined’.</code>。为什么？</p> <p><code>click</code>事件监听函数闭包的<code>this</code>关键字共享了包裹它的<code>this</code>关键字。在本例中它被包裹的箭头函数<code>clickMe</code>，<code>clickMe</code>箭头函数的<code>this</code>关键字指向全局对象，本例中是<code>window</code>对象。所以<code>this.color</code>和<code>this.position</code>将会是<code>undefined</code>因为<code>window</code>对象没有<code>position</code>和<code>color</code>属性。</p> <p>我想再给你看个在很多情况下都会有帮助的<code>map</code>函数，我们定义一个<code>Person</code>构造函数方法如下：</p> <div class="language- extra-class"><pre class="language-text"><code>function Person(firstName, lastName) {
    this.firstName = firstName;
    this.lastName = lastName;
    this.displayName = function() {
        console.log(`Name: ${this.firstName} ${this.lastName}`);
    }
}
</code></pre></div><p><code>Person</code>的原型上添加<code>myFriends</code>方法：</p> <div class="language- extra-class"><pre class="language-text"><code>Person.prototype.myFriends = function(friends) {
    var arr = friends.map(function(friend) {
        return this.firstName + ' is friends with ' + friend;
    });
    console.log(arr);
}
</code></pre></div><p>创建一个实例：</p> <div class="language- extra-class"><pre class="language-text"><code>let john = new Person(&quot;John&quot;, &quot;Watson&quot;);
</code></pre></div><p>调用<code>john.myFriends([&quot;Emma&quot;, &quot;Tom&quot;])</code>，结果：</p> <div class="language- extra-class"><pre class="language-text"><code>[&quot;undefined is friends with Emma&quot;, &quot;undefined is friends with Tom&quot;]
</code></pre></div><p>本例与之前的例子非常相似。<code>myFriends</code>函数体内有<code>this</code>关键字指向回调对象。但是，<code>map</code>闭包函数内是一个普通函数调用。所以<code>map</code>闭包函数内<code>this</code>指向全局对象，本例中为<code>window</code>对象，因此<code>this.firstName</code>undefined。现在，我们试着修复这个情况。</p> <ol><li>在<code>myFriends</code>函数体内指定<code>this</code>为其它变量如<code>self</code>，以便<code>map</code>函数内闭包使用它。</li></ol> <div class="language- extra-class"><pre class="language-text"><code>Person.prototype.myFriends = function(friends) {
    // 'this' keyword maps to the calling object
    var self = this;
    var arr = friends.map(function(friend) {
        // 'this' keyword maps to the global object
        // here, 'this.firstName' is undefined.
        return self.firstName + ' is friends with ' + friend;
    });
    console.log(arr);
}
</code></pre></div><ol start="2"><li><code>map</code>闭包函数使用<code>bind</code>。</li></ol> <div class="language- extra-class"><pre class="language-text"><code>Person.prototype.myFriends = function(friends) {
    // 'this' keyword maps to the calling object
    var arr = friends.map(function(friend) {
        // 'this' keyword maps to the global object
        // here, 'this.firstName' is undefined.
        return this.firstName + ' is friends with ' + friend;
    }.bind(this));
    console.log(arr);
}
</code></pre></div><p>调用<code>bind</code>会返回一个<code>map</code>回调函数的副本，<code>this</code>关键字映射到外层的<code>this</code>关键字，也就是是调用<code>myFriends</code>方法，<code>this</code>指向这个对象。</p> <ol start="3"><li>创建<code>map</code>回调函数为箭头函数。</li></ol> <div class="language- extra-class"><pre class="language-text"><code>Person.prototype.myFriends = function(friends) {
    var arr = friends.map(friend =&gt; `${this.firstName} is friends with ${friend}`);
    console.log(arr);
}
</code></pre></div><p>现在，箭头函数内的<code>this</code>关键字将共享未曾包裹它的词法作用域，也就是说实例<code>myFriends</code>。</p> <p>所有以上解决方案都将输出结果：</p> <div class="language- extra-class"><pre class="language-text"><code>[&quot;John is friends with Emma&quot;, &quot;John is friends with Tom&quot;]
</code></pre></div><p>...</p> <p>在这一点上，我希望我已经设法使<code>this</code>关键字概念对您来说有点平易近人。在本文中，我分享了我遇到的一些常见情况以及如何处理它们，但当然，在构建更多项目时，您将面临更多情况。我希望我的解释可以帮助您在接近<code>this</code>关键字绑定主题时保持坚实的基础。如果您有任何问题，建议或改进，我总是乐于学习更多知识并与所有知名开发人员交流知识。请随时写评论，或给我留言！</p></div> <div class="page-edit"><div class="edit-link"><a href="https://github.com/chinadbo/blog/edit/master/docs/frontend/jsthis.md" target="_blank" rel="noopener noreferrer">帮助改善页面！</a> <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></div> <div class="last-updated"><span class="prefix">Last Updated: </span> <span class="time">3/14/2019, 5:46:53 PM</span></div></div> <!----> </div> <!----></div></div>
    <script src="/blog/assets/js/app.7b3236d9.js" defer></script><script src="/blog/assets/js/9.4cea35d1.js" defer></script>
  </body>
</html>
