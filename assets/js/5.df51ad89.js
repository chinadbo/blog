(window.webpackJsonp=window.webpackJsonp||[]).push([[5],{173:function(a,e,t){"use strict";t.r(e);var r=t(0),n=Object(r.a)({},function(){this.$createElement;this._self._c;return this._m(0)},[function(){var a=this,e=a.$createElement,t=a._self._c||e;return t("div",{staticClass:"content"},[t("h1",{attrs:{id:"javascript如何深度拷贝一个数组"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#javascript如何深度拷贝一个数组","aria-hidden":"true"}},[a._v("#")]),a._v(" JavaScript如何深度拷贝一个数组")]),a._v(" "),t("p",[t("img",{attrs:{src:"https://user-gold-cdn.xitu.io/2019/3/6/169521d1f4660caa?w=698&h=330&f=png&s=63412",alt:""}}),a._v("\n有两种数组拷贝类型："),t("strong",[a._v("浅拷贝 & 深拷贝")]),a._v("。"),t("strong",[a._v("浅拷贝")]),a._v("只会拷贝数组的第一层，剩下的会引用。如果你需要一个嵌套的数组的拷贝，那需要你去深度拷贝这个数组。"),t("strong",[a._v("深拷贝")]),a._v("，选择JSON方法或者Lodsh库吧👍")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("const numbers = [1, [2], [3, [4]], 5];\n// Using JavaScript\nJSON.parse(JSON.stringify(numbers));\n// Using Lodash\n_.cloneDeep(objects);\n")])])]),t("h2",{attrs:{id:"数组是引用类型"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#数组是引用类型","aria-hidden":"true"}},[a._v("#")]),a._v(" 数组是引用类型")]),a._v(" "),t("p",[a._v("为了搞清楚为什么有两种类型的拷贝，我们来深度了解一下基础知识然后解释什么是引用类型。")]),a._v(" "),t("p",[a._v("与原始类型（number、string）不同，数组是引用类型。这意味着当你把一个数组赋值给一个变量，你是将数组的内存地址而非数组本身赋给变量。 😱")]),a._v(" "),t("h2",{attrs:{id:"拷贝值类型"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#拷贝值类型","aria-hidden":"true"}},[a._v("#")]),a._v(" 拷贝值类型")]),a._v(" "),t("p",[a._v("这里没什么大不了的，我们创建一个"),t("code",[a._v("value")]),a._v("的拷贝。当我们改变"),t("code",[a._v("valueCopy")]),a._v("的值，它不会影响原来的"),t("code",[a._v("value")]),a._v("值。同理，当我们改变原来的值它也不会影响拷贝后的值。很好👍")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("let value = 3;\nlet valueCopy = value; // create copy\nconsole.log(valueCopy); // 3\n// Change valueCopy\nvalueCopy = 100\nconsole.log(valueCopy); // 100\n// ✅ Original NOT affected \nconsole.log(value); // 3\n")])])]),t("h2",{attrs:{id:"拷贝引用类型"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#拷贝引用类型","aria-hidden":"true"}},[a._v("#")]),a._v(" 拷贝引用类型")]),a._v(" "),t("p",[a._v("好的，这里就会有点奇怪了！我们用同样的方法拷贝数组。")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("let array = [1,2,3];\nlet arrayCopy = array; // create copy\nconsole.log(arrayCopy); // [1,2,3];\n// Change 1st element of the array\narrayCopy[0] = '👻';\nconsole.log(arrayCopy); // [ '👻', 2, 3 ]\n// ❌Original got affected\nconsole.log(array); // [ '👻', 2, 3 ]\n")])])]),t("p",[a._v("为什么原来的数组也受到了影响呢？好了，是因为："),t("strong",[a._v("你拷贝的不是你拷贝的")]),a._v("。说人话，意思就是你拷贝的只是"),t("strong",[a._v("指向数组内存空间的指针")]),a._v("。引用类型不包含值，它们是指向内存中值的"),t("strong",[a._v("指针")]),a._v("。")]),a._v(" "),t("h3",{attrs:{id:"拷贝引用类型的方法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#拷贝引用类型的方法","aria-hidden":"true"}},[a._v("#")]),a._v(" 拷贝引用类型的方法")]),a._v(" "),t("p",[a._v("解决方法就是拷贝值而不是指针。")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("let array = [1,2,3];\nlet arrayCopy = [...array]; // create TRUE copy\nconsole.log(arrayCopy); // [1,2,3];\n// Change 1st element of the array\narrayCopy[0] = '👻';\nconsole.log(arrayCopy); // [ '👻', 2, 3 ]\n// ✅ Original NOT affected \nconsole.log(array); // [ 1, 2, 3 ]\n")])])]),t("h2",{attrs:{id:"浅-深-拷贝"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#浅-深-拷贝","aria-hidden":"true"}},[a._v("#")]),a._v(" 浅 & 深 拷贝")]),a._v(" "),t("p",[a._v("当我使用展开扩展符号"),t("code",[a._v("...")]),a._v("来拷贝一个数组，我只是浅拷贝了一个数组。如果数组是嵌套或者多维的，这就不奏效了。")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("let nestedArray = [1, [2], 3];\nlet arrayCopy = [...nestedArray];\n// Make some changes\narrayCopy[0] = '👻'; // change shallow element\narrayCopy[1][0] = '💩'; // change nested element\nconsole.log(arrayCopy); // [ '👻', [ '💩' ], 3 ]\n// ❌ Nested array got affected\nconsole.log(nestedArray); // [ 1, [ '💩' ], 3 ]\n")])])]),t("p",[a._v("如上，浅拷贝首层数组表现良好，然而，更改了嵌套数组元素，原始数组也受到影响💩。为了解决这个问题，就要用到"),t("strong",[a._v("深拷贝")]),a._v("了。")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("let nestedArray = [1, [2], 3];\nlet arrayCopy = JSON.parse(JSON.stringify(nestedArray));\n// Make some changes\narrayCopy[0] = '👻'; // change shallow element\narrayCopy[1][0] = '💩'; // change nested element\nconsole.log(arrayCopy); // [ '👻', [ '💩' ], 3 ]\n// ✅ Nested array NOT affected\nconsole.log(nestedArray); //  1, [ 2 ], 3 ]\n")])])]),t("p",[a._v("所以，这就完事了吗？要不要手写一个深拷贝引用类型的方法？")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("const deepClone = obj => {\n    const isObject = args => (typeof args === 'object' || typeof args === 'function') && typeof args !== null\n    if (!isObject) throw new Error('Not Reference Types')\n    let newObj = Array.isArray(obj) ? [...obj] : { ...obj }\n    Reflect.ownKeys(newObj).map(key => {\n        newObj[key] = isObject(obj[key]) ? deepClone(obj[key]) : obj[key]\n    })\n    return newObj\n}\n")])])]),t("p",[a._v("✅ ✅ ✅")])])}],!1,null,null,null);e.default=n.exports}}]);